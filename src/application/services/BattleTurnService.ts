import { Pet } from "@domain/entities/Pet";
import { Skill } from "@domain/entities/Skill";
import { ChannelMessageContent } from "mezon-sdk";
import TurnResult from "@/domain/entities/TurnResult";
import { IBattleService } from "@/domain/interfaces/services/IBattleService";
import { IPetRepository } from "@/domain/interfaces/repositories/IPetRepository";
import { EffectTypes } from "@/domain/enums/EffectTypes";
import { AffectTypes } from "@/domain/enums/AffectTypes";
import { PassiveAbilityService } from "@/infrastructure/services/PassiveAbilityService";
import { ELEMENT_EMOJIS } from "@/application/constants/ElementEmojis";
import { SPECIES_EMOJIS } from "@/application/constants/SpeciesEmojis";
import { createSkillUsageEmbed, createTurnStatusEmbed, createTurnEndStatusEmbed } from "@/infrastructure/utils/Embed";
import { BattleStatus } from "@/domain/entities/BattleStatus";
import { Logger } from "@/shared/utils/Logger";

/**
 * Service responsible for executing battle turns and handling turn-based logic
 */
export class BattleTurnService {
  constructor(
    private petRepository: IPetRepository,
    private battleService: IBattleService
  ) { }

  /**
   * Process the end of turn status effects for a pet
   * @param pet The pet to process status effects for
   * @param sendMessage Function to send messages to the channel
   * @returns Promise that resolves when processing is complete
   */
  async processEndOfTurnStatus(
    pet: Pet, 
    sendMessage: (payload: ChannelMessageContent) => Promise<void>
  ): Promise<void> {
    Logger.info(`X·ª≠ l√Ω hi·ªáu ·ª©ng cu·ªëi l∆∞·ª£t cho th√∫ ${pet.name}`);
    for (let i = pet.statusEffects.length - 1; i >= 0; i--) {
      const status = pet.statusEffects[i];
      const statusEffect = status.statusEffect;
      status.turnsRemaining--;

      switch (statusEffect.type) {
        case EffectTypes.BURN:
          const dotDamage = this.battleService.calculateDotDamage(pet, statusEffect);
          pet.hp = Math.max(0, pet.hp - dotDamage);
          await sendMessage({
            t: `üî• **${pet.name}** b·ªã b·ªèng! Nh·∫≠n **${dotDamage}** s√°t th∆∞∆°ng!`
          });
          break;
        case EffectTypes.POISON:
          const poisonDamage = this.battleService.calculateDotDamage(pet, statusEffect);
          pet.hp = Math.max(0, pet.hp - poisonDamage);
          await sendMessage({
            t: `‚ò†Ô∏è **${pet.name}** b·ªã ng·ªô ƒë·ªôc! Nh·∫≠n **${poisonDamage}** s√°t th∆∞∆°ng!`
          });
          break;
        case EffectTypes.SLOW:
          break;
        case EffectTypes.BUFF:
          break;
        case EffectTypes.DEBUFF:
          break;
        case EffectTypes.FREEZE:
          await sendMessage({
            t: `üßä **${pet.name}** b·ªã ƒë√≥ng bƒÉng v√† kh√¥ng th·ªÉ di chuy·ªÉn!`
          });
          break;
        case EffectTypes.BLIND:
          break;
        case EffectTypes.PARALYZE:
          break;
        case EffectTypes.STUN:
          await sendMessage({
            t: `üí´ **${pet.name}** b·ªã cho√°ng v√† kh√¥ng th·ªÉ di chuy·ªÉn!`
          });
          break;
      }

      if (status.turnsRemaining <= 0) {
        await sendMessage({
          t: `‚ú® Hi·ªáu ·ª©ng ${statusEffect.type} c·ªßa **${pet.name}** ƒë√£ h·∫øt.`
        });
        pet.statusEffects.splice(i, 1);
      }
    }
  }

  /**
   * Select a skill for a pet to use based on available energy and level
   * @param pet The pet to select a skill for
   * @returns The selected skill
   */
  selectSkill(pet: Pet): Skill {
    Logger.info(`Ch·ªçn k·ªπ nƒÉng cho th√∫ ${pet.name}`);
    
    // Check if pet should use ultimate skill (below 30% HP)
    const ultimateSkill = this.battleService.checkForUltimateSkill(pet);
    if (ultimateSkill) {
      Logger.info(`${pet.name} s·∫Ω s·ª≠ d·ª•ng k·ªπ nƒÉng ultimate: ${ultimateSkill.name}`);
      return ultimateSkill;
    }
    
    const availableSkills = pet.skills.filter(skill => skill.energyCost && skill.energyCost <= pet.energy && skill.levelReq <= pet.level);
    Logger.info(`Avaliable skill ${pet.skills[0]}`)
    if (availableSkills.length === 0) {
      return pet.skills[0]
    }
    // random
    return availableSkills[Math.floor(Math.random() * availableSkills.length)];
  }

  /**
   * Execute a single pet's turn in battle
   * @param attackingPet The pet that is attacking
   * @param defendingPet The pet that is defending
   * @param sendMessage Function to send messages to the channel
   * @returns Result of the turn execution
   */
  async executePetTurn(
    attackingPet: Pet,
    defendingPet: Pet,
    sendMessage: (payload: ChannelMessageContent) => Promise<void>
  ): Promise<TurnResult> {
    Logger.info(`Th·ª±c hi·ªán l∆∞·ª£t c·ªßa ${attackingPet.name} ch·ªëng l·∫°i ${defendingPet.name}`);
    const isFrozen = attackingPet.statusEffects.some(status => status.statusEffect.type === EffectTypes.FREEZE);
    const isStunned = attackingPet.statusEffects.some(status => status.statusEffect.type === EffectTypes.STUN);
    
    if (isFrozen || isStunned) {
      await sendMessage({
        t: `‚ùå **${attackingPet.name}** kh√¥ng th·ªÉ di chuy·ªÉn!`
      });
      return { isDefeated: false, expGain: 0 };
    }

    const isParalyzed = attackingPet.statusEffects.some(status => status.statusEffect.type === EffectTypes.PARALYZE);
    if (isParalyzed && Math.random() > 0.3) {
      await sendMessage({
        t: `‚ö° **${attackingPet.name}** b·ªã t√™ li·ªát v√† kh√¥ng th·ªÉ di chuy·ªÉn!`
      });
      return { isDefeated: false, expGain: 0 };
    }

    const skill = this.selectSkill(attackingPet);
    
    // Check for Wind Mastery passive ability dodge
    const windMasteryEffect = PassiveAbilityService.handleWindMastery(defendingPet, 0);
    if (windMasteryEffect.dodge) {
      await sendMessage({
        t: `üí® **${defendingPet.name}** ƒë√£ n√© ƒë√≤n t·∫•n c√¥ng!`
      });
      if (windMasteryEffect.energyRecovered > 0) {
        await sendMessage({
          t: `‚ö° **${defendingPet.name}** ƒë√£ ph·ª•c h·ªìi ${windMasteryEffect.energyRecovered} nƒÉng l∆∞·ª£ng!`
        });
      }
      return { isDefeated: false, expGain: 0 };
    }
    
    // Check for Electric Field passive ability counter attack
    const electricFieldEffect = PassiveAbilityService.handleElectricField(defendingPet, attackingPet, 0);
    if (electricFieldEffect.counter) {
      await sendMessage({
        t: `‚ö° **${defendingPet.name}** ƒë√£ ph·∫£n ƒë√≤n t·∫•n c√¥ng!`
      });
      
      // Apply counter damage to attacker
      attackingPet.hp = Math.max(0, attackingPet.hp - electricFieldEffect.counterDamage);
      await sendMessage({
        t: `‚ö° **${attackingPet.name}** nh·∫≠n **${electricFieldEffect.counterDamage}** s√°t th∆∞∆°ng ph·∫£n ƒë√≤n!`
      });
      
      // Apply paralyze effect if triggered
      if (electricFieldEffect.paralyze) {
        const paralyzeStatus: BattleStatus = {
          statusEffect: {
            type: EffectTypes.PARALYZE,
            target: "enemy",
            chance: 100,
            turns: 1,
            value: 1,
            valueType: "flag",
          },
          turnsRemaining: 1,
          turnsTotal: 1,
        };
        attackingPet.statusEffects.push(paralyzeStatus);
        await sendMessage({
          t: `‚ö° **${attackingPet.name}** b·ªã t√™ li·ªát!`
        });
      }
      
      // If attacker is defeated by counter attack, return immediately
      if (attackingPet.hp <= 0) {
        return { isDefeated: true, winner: defendingPet.id, expGain: 0 };
      }
    }
    
    const damageResult = this.battleService.calculateSkillDamage(attackingPet, defendingPet, skill);

    const elementEmoji = ELEMENT_EMOJIS[skill.element] || "";
    await sendMessage({
      t: '',
      embed: [createSkillUsageEmbed(attackingPet, skill, damageResult)]
    });

    if (damageResult.isCrit) {
      await sendMessage({
        t: "üí• **Ch√≠ m·∫°ng!**"
      });
    }

    let effectivenessMessage = "";
    switch (damageResult.effectiveness) {
      case "super effective":
        effectivenessMessage = "üéØ Hi·ªáu qu·∫£ cao!";
        break;
      case "not very effective":
        effectivenessMessage = "üõ°Ô∏è Hi·ªáu qu·∫£ th·∫•p...";
        break;
      default:
        effectivenessMessage = "‚úÖ Tr√∫ng ƒë√≠ch!";
    }
    await sendMessage({
      t: `${effectivenessMessage} G√¢y **${damageResult.damage}** s√°t th∆∞∆°ng!`
    });

    defendingPet.hp = Math.max(0, defendingPet.hp - damageResult.damage);
    attackingPet.energy -= skill.energyCost!;

    // Handle Electric Field passive ability energy recovery
    const energyRecovered = PassiveAbilityService.handleElectricSkillEnergyRecovery(attackingPet, skill);
    if (energyRecovered > 0) {
      await sendMessage({
        t: `‚ö° **${attackingPet.name}** ƒë√£ ph·ª•c h·ªìi ${energyRecovered} nƒÉng l∆∞·ª£ng t·ª´ k·ªπ nƒÉng ƒëi·ªán!`
      });
    }

    await sendMessage({
      t: `${SPECIES_EMOJIS[defendingPet.species] || "üêæ"} **${defendingPet.name}** | HP: ${defendingPet.hp}/${defendingPet.maxHp}`
    });

    if (damageResult.statusApplied && skill.statusEffect && skill.statusEffect.length > 0) {
      for (let i = 0; i < skill.statusEffect.length; i++) {
        const statusEffect = skill.statusEffect[i];
        const applied = damageResult.statusApplied[i];
        
        if (applied) {
          const newStatus: BattleStatus = {
            statusEffect: { ...statusEffect, sourceAtk: attackingPet.attack },
            turnsRemaining: statusEffect.turns,
            turnsTotal: statusEffect.turns,
          };

          switch (statusEffect.type) {
            case EffectTypes.BURN:
              if (statusEffect.target === 'enemy') {
                defendingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `üî• **${defendingPet.name}** b·ªã b·ªèng!`
                });
              } else if (statusEffect.target === 'self') {
                attackingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `üî• **${attackingPet.name}** b·ªã b·ªèng!`
                });
              }
              break;
            case EffectTypes.FREEZE:
              if (statusEffect.target === 'enemy') {
                defendingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `üßä **${defendingPet.name}** b·ªã ƒë√≥ng bƒÉng!`
                });
              } else if (statusEffect.target === 'self') {
                attackingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `üßä **${attackingPet.name}** b·ªã ƒë√≥ng bƒÉng!`
                });
              }
              break;
            case EffectTypes.PARALYZE:
              if (statusEffect.target === 'enemy') {
                defendingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `‚ö° **${defendingPet.name}** b·ªã t√™ li·ªát!`
                });
              } else if (statusEffect.target === 'self') {
                attackingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `‚ö° **${attackingPet.name}** b·ªã t√™ li·ªát!`
                });
              }
              break;
            case EffectTypes.POISON:
              if (statusEffect.target === 'enemy') {
                defendingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `‚ò†Ô∏è **${defendingPet.name}** b·ªã ng·ªô ƒë·ªôc!`
                });
              } else if (statusEffect.target === 'self') {
                attackingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `‚ò†Ô∏è **${attackingPet.name}** b·ªã ng·ªô ƒë·ªôc!`
                });
              }
              break;
            case EffectTypes.BLIND:
              if (statusEffect.target === 'enemy') {
                defendingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `üëÅÔ∏è **${defendingPet.name}** b·ªã m√π!`
                });
              } else if (statusEffect.target === 'self') {
                attackingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `üëÅÔ∏è **${attackingPet.name}** b·ªã m√π!`
                });
              }
              break;
            case EffectTypes.SLOW:
              if (statusEffect.target === 'enemy') {
                defendingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `ü¶• **${defendingPet.name}** b·ªã ch·∫≠m!`
                });
              } else if (statusEffect.target === 'self') {
                attackingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `ü¶• **${attackingPet.name}** b·ªã ch·∫≠m!`
                });
              }
              break;
            case EffectTypes.STUN:
              if (statusEffect.target === 'enemy') {
                defendingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `üí´ **${defendingPet.name}** b·ªã cho√°ng!`
                });
              } else if (statusEffect.target === 'self') {
                attackingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `üí´ **${attackingPet.name}** b·ªã cho√°ng!`
                });
              }
              break;
            case EffectTypes.BUFF:
              if (statusEffect.target === 'self') {
                attackingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `‚¨ÜÔ∏è ${statusEffect.stat} c·ªßa **${attackingPet.name}** tƒÉng l√™n!`
                });
              }
              break;
            case EffectTypes.DEBUFF:
              if (statusEffect.target === 'enemy') {
                defendingPet.statusEffects.push(newStatus);
                await sendMessage({
                  t: `‚¨áÔ∏è ${statusEffect.stat} c·ªßa **${defendingPet.name}** gi·∫£m xu·ªëng!`
                });
              }
              break;
          }
        }
      }
    }

    const energyStealEffect = skill.statusEffect?.find(s => s.affects === AffectTypes.HEAL_ON_DAMAGE);
    if (energyStealEffect && energyStealEffect.valueType === 'percentage') {
      const energyStolen = 2;
      if (energyStolen > 0) {
        attackingPet.energy = Math.min(attackingPet.maxEnergy, attackingPet.energy + energyStolen);
        defendingPet.energy = Math.max(0, defendingPet.energy - energyStolen);
        await sendMessage({
          t: `‚ö° **${attackingPet.name}** ƒë√£ ƒë√°nh c·∫Øp ${energyStolen} nƒÉng l∆∞·ª£ng t·ª´ **${defendingPet.name}**!`
        });
      }
    }

    if (defendingPet.hp <= 0) {
      await sendMessage({
        t: `üí• **${defendingPet.name}** ƒë√£ ng·∫•t x·ªâu!`
      });
      return { isDefeated: true, winner: attackingPet.id, expGain: 0 };
    }

    return { isDefeated: false, expGain: 0 };
  }
}